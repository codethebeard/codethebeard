@mixin respond($bp, $determinate : min) {
	@media screen and ( $determinate+-width: $bp ) { @content; }
}
@mixin respondBetween($min,$max) {
	@media screen and (min-width: #{$min}) and (max-width: #{$max}) { @content; }
}

// create a set of row rules for a given size
@mixin flex-grid-size($size: '', $cols: 12, $colWidth: 8.333%, $gutter: 1.667%) {

	// rows
	// direction
	[data-flex#{$size}~="row"] {
		flex-direction: row;
		&[data-flex#{$size}~="reverse"] { flex-direction: row-reverse; }
	}
	[data-flex#{$size}~="vertical"] {
		flex-direction: column;
		&[data-flex#{$size}~="reverse"] { flex-direction: column-reverse; }
	}

	// wrap
	[data-flex#{$size}~="wrap"] 				{ flex-wrap: wrap; }
	[data-flex#{$size}~="nowrap"]				{ flex-wrap: nowrap; }
	[data-flex#{$size}~="wraprev"] 			{ flex-wrap: wrap-reverse; }

	// horizontal alignment
	[data-flex#{$size}~="center"] 			{ justify-content: center; }
	[data-flex#{$size}~="between"] 			{ justify-content: space-between; }
	[data-flex#{$size}~="around"] 			{ justify-content: space-around; }
	[data-flex#{$size}~="start"] 				{ justify-content: flex-start; }
	[data-flex#{$size}~="end"] 					{ justify-content: flex-end; }

	// only do margin on certain aligns
	[data-flex#{$size}~="start"],
	[data-flex#{$size}~="center"],
	[data-flex#{$size}~="end"] {
		[data-col] {
			margin-right: $gutter;
			&:last-of-type { margin-right: 0; }
		}
	}

	// @TODO handle flush/gutters better, either add gutter or remove gutter
	//				need two different column widths
	// [data-flex#{$size}~="flush"] [data-col] { margin-right: 0; }

	// vertical alignment
	[data-flex#{$size}~="top"] 					{ align-items: flex-start; }
	[data-flex#{$size}~="middle"] 			{ align-items: center; }
	[data-flex#{$size}~="bottom"] 			{ align-items: flex-end; }
	[data-flex#{$size}~="stretch"] 			{ align-items: stretch; }
	[data-flex#{$size}~="baseline"] 		{ align-items: baseline; }

	// @TODO: Does not include the "align-content" rules

	// columns
	// alignments
	[data-col#{$size}~="top"] 					{ align-self: flex-start; }
	[data-col#{$size}~="middle"] 				{ align-self: center; }
	[data-col#{$size}~="bottom"] 				{ align-self: flex-end; }
	[data-col#{$size}~="stretch"] 			{ align-self: stretch; }
	[data-col#{$size}~="baseline"] 			{ align-self: baseline; }

	// sizes
	$i: $cols;

	[data-col#{$size}="0"] { display: none; }
	@while $i > 0 {

		// column
		[data-col#{$size}~="#{$i}"] {
			display: block;
			flex-basis: ($colWidth * $i) + ($gutter * ($i - 1));
			[data-flex#{$size}~="vertical"] & { width: ($colWidth * $i) + ($gutter * ($i - 1)); }
		}

		$i: $i - 1;
	}
}

@mixin flex-grid($cols: 12, $gutter: 20px, $papa: 1140px, $mama: 768px, $baby: 400px) {

	$colWidth: percentage((($papa - (($cols - 1) * $gutter)) / $cols)/$papa);
	$gutter: percentage($gutter/$papa);

	// null - default, mobile first
	@include flex-grid-size('', $cols, $colWidth, $gutter);

	// -sm : $baby ^
	@include respond($baby) {
		@include flex-grid-size('-sm', $cols, $colWidth, $gutter);
	}

	// -md : $mama ^
	@include respond($mama) {
		@include flex-grid-size('-md', $cols, $colWidth, $gutter);
	}

	// -lg : $papa ^
	@include respond($papa) {
		@include flex-grid-size('-lg', $cols, $colWidth, $gutter);
	}
}

.clearfix:after {
  content: "";
  display: table;
  clear: both;
}
